delimiter = '*'
# * generated by docraiser *
class Builder
	constructor: (@frame) ->
		@body = document.getElementById('main')
		console.log(@frame.to_str())
		@build(@frame.get_active())

	build: (node) ->
		console.log("#{node.type} #{node.val}")
		element = no
		if node.type is 'heading'
			element = document.createElement("h#{node.level}")
		if node.type is 'text'
			element = document.createElement('a')
		element.innerHTML = node.val
		@body.appendChild(element)

		for a in node.children
			@build(a)

class Barn
	constructor: ->
		# @level = 1
		@split_text_list = window.output.split(' ')
		@frame = {}
		@list = new NodeList()
		# console.log(@split_text_list)

	parse: ->
		closer = no
		for index in [0...@split_text_list.length]
			# console.log(@split_text_list[index])
			if @split_text_list[index] is delimiter
				console.log('found delimiter')
				if not closer
					num = parseInt(@split_text_list[index + 1],10)
					console.log(num)
					if isNaN(num)
						@add_node(index + 1,no,'text')
					if num == @list.current_level
						@add_node(index + 2)
						# level += 1
					if num < @list.current_level
						@list.goto_level(num)
						@add_node(index + 2)
					if num is @list.current_level + 1
						@add_node(index + 2,no)
					closer = yes
				else
					closer = no

		@list.goto_level(1)
		# console.log(@list.to_str())
		builder = new Builder(@list)

	add_node: (index,stepback=yes,type='heading') ->
		if stepback
			@list.back()
		res = ""
		for word in @split_text_list[index..]
			if word isnt delimiter
				res += "#{word} " 
				console.log(word) 
			else break
		@list.add(new Node(res,type))

class Node
	constructor: (@val,@type) ->
		# a node could have many children but only one parent
		@children = []
		@parent = no
		@level = 0

	to_str: () ->
		ret = "#{@val}(#{@level}):["
		ret += "#{child.to_str()} " for child in @children
		ret += ']'
		return ret

class NodeList
	constructor: ->
		@active_node = new Node('first')
		@current_level = 0

	add: (node) ->
		# before adding, check if the node is already added
		for child in @active_node.children
			if child.val is node.val
				@active_node = child
				@current_level += 1
				return no
		@active_node.children.push(node)
		node.parent = @active_node
		@active_node = node
		console.log("new active node: #{@active_node.val}")
		@current_level += 1
		@active_node.level = @current_level

	back: ->
		console.log(@active_node.val)
		@active_node = @active_node.parent
		@current_level -= 1

	goto_level: (level,node=no) ->
		console.log("going to level #{level}")
		if level == @current_level
			return yes
		if level < @current_level
			console.log(@current_level)
			@back() while @current_level isnt level
		if level > @current_level
			console.log("cant move forwards through the nodelist!!")

	to_str: ->
		level = @current_level
		console.log("to_str called on level #{level}")
		@back() while @current_level isnt 1
		ret = @active_node.to_str()
		# @goto_level(level)
		return ret

	get_active: ->
		@active_node

barn = new Barn()
barn.parse()
console.log(barn.list.to_str())