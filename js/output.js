window.output = "# docraiser a simple and versatile heading-based documentation generator.  <!DOCTYPE html> <html>  <head>   <script type=_text/javascript_ src='js/output.js'></script>  </head>    <body id='main'>   </body>   <script type=_text/javascript_ src='http://coffeescript.org/extras/coffee-script.js'></script>  <script type=_text/coffeescript_ src='coffee/main.coffee'></script> </html> import os,sys  def get_wood(current_dir = None):  files = []  if not current_dir:   current_dir = os.path.dirname(os.path.abspath(__file__))  open('%s/js/output.js' % current_dir,'w').close()  for dirpath, dirname, filename in os.walk(current_dir):   if '.git' not in dirpath:     for a in filename:     files.append('%s/%s' % (dirpath,a))  file_text_split = ''  for file_path in files:   with open(file_path,'r+') as w:    file_text_split += w.read().replace('\n',' ').replace('\t',' ').replace('_','_') + ' '  with open('%s/js/output.js' % current_dir,'w') as fi:   fi.write('window.output = _%s_' % file_text_split)  if __name__ == '__main__':  try:   get_wood(sys.argv[1])  except IndexError:   get_wood()  delimiter = '*' # * generated by docraiser * class Builder  constructor: (@frame) ->   @body = document.getElementById('main')   console.log(@frame.to_str())   @build(@frame.get_active())   build: (node) ->   console.log(_#{node.type} #{node.val}_)   element = no   if node.type is 'heading'    element = document.createElement(_h#{node.level}_)   if node.type is 'text'    element = document.createElement('a')   element.innerHTML = node.val   @body.appendChild(element)    for a in node.children    @build(a)  class Barn  constructor: ->   # @level = 1   @split_text_list = window.output.split(' ')   @frame = {}   @list = new NodeList()   # console.log(@split_text_list)   parse: ->   closer = no   for index in [0...@split_text_list.length]    # console.log(@split_text_list[index])    if @split_text_list[index] is delimiter     console.log('found delimiter')     if not closer      num = parseInt(@split_text_list[index + 1],10)      console.log(num)      if isNaN(num)       @add_node(index + 1,no,'text')      if num == @list.current_level       @add_node(index + 2)       # level += 1      if num < @list.current_level       @list.goto_level(num)       @add_node(index + 2)      if num is @list.current_level + 1       @add_node(index + 2,no)      closer = yes     else      closer = no    @list.goto_level(1)   # console.log(@list.to_str())   builder = new Builder(@list)   add_node: (index,stepback=yes,type='heading') ->   if stepback    @list.back()   res = __   for word in @split_text_list[index..]  # * 1 something goes here * # * 2 something goes under this something * # * 3 something else * # * 4 something else else * # * 5 what am i even doing right now * # * 6 wubalubba dub dub * # * poop *  if word isnt delimiter     res += _#{word} _      console.log(word)     else break   @list.add(new Node(res,type))  class Node  constructor: (@val,@type) ->   # a node could have many children but only one parent   @children = []   @parent = no   @level = 0   to_str: () ->   ret = _#{@val}(#{@level}):[_   ret += _#{child.to_str()} _ for child in @children   ret += ']'   return ret  class NodeList  constructor: ->   @active_node = new Node('first')   @current_level = 0   add: (node) ->   # before adding, check if the node is already added   for child in @active_node.children    if child.val is node.val     @active_node = child     @current_level += 1     return no   @active_node.children.push(node)   node.parent = @active_node   @active_node = node   console.log(_new active node: #{@active_node.val}_)   @current_level += 1   @active_node.level = @current_level   back: ->   console.log(@active_node.val)   @active_node = @active_node.parent   @current_level -= 1   goto_level: (level,node=no) ->   console.log(_going to level #{level}_)   if level == @current_level    return yes   if level < @current_level    console.log(@current_level)    @back() while @current_level isnt level   if level > @current_level    console.log(_cant move forwards through the nodelist!!_)   to_str: ->   level = @current_level   console.log(_to_str called on level #{level}_)   @back() while @current_level isnt 1   ret = @active_node.to_str()   # @goto_level(level)   return ret   get_active: ->   @active_node  barn = new Barn() barn.parse() console.log(barn.list.to_str()) "
