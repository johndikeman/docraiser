window.output = "<!DOCTYPE html> <html>  <head>     </head>    <body id='main'>   </body>   <script type=_text/javascript_ src='js/output.js'></script>  <script type=_text/javascript_ src='js/main.js'></script> </html> import os  def get_wood():  files = []  current_dir = os.path.dirname(os.path.abspath(__file__))  open('%s/js/output.js' % current_dir,'w').close()  for dirpath, dirname, filename in os.walk(current_dir):   for a in filename:    files.append('%s/%s' % (dirpath,a))  file_text_split = ''  for file_path in files:   with open(file_path,'r+') as w:    file_text_split += w.read().replace('\n',' ').replace('\t',' ').replace('_','_') + ' '  with open('%s/js/output.js' % current_dir,'w') as fi:   fi.write('window.output = _%s_' % file_text_split)  if __name__ == '__main__':  get_wood() // Generated by CoffeeScript 1.10.0 (function() {   var Barn, Builder, Node, NodeList, barn, delimiter;    delimiter = '*';    Builder = (function() {     function Builder(frame) {       this.frame = frame;       this.body = document.getElementById('main');       console.log(this.frame.to_str());       this.build(this.frame.get_active());     }      Builder.prototype.build = function(node) {       var a, element, i, len, ref, results;       console.log(node.type + _ _ + node.val);       element = false;       if (node.type === 'heading') {         element = document.createElement(_h_ + node.level);       }       if (node.type === 'text') {         element = document.createElement('a');       }       element.innerHTML = node.val;       this.body.appendChild(element);       ref = node.children;       results = [];       for (i = 0, len = ref.length; i < len; i++) {         a = ref[i];         results.push(this.build(a));       }       return results;     };      return Builder;    })();    Barn = (function() {     function Barn() {       this.split_text_list = window.output.split(' ');       this.frame = {};       this.list = new NodeList();     }      Barn.prototype.parse = function() {       var builder, closer, i, index, num, ref;       closer = false;       for (index = i = 0, ref = this.split_text_list.length; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {         if (this.split_text_list[index] === delimiter) {           console.log('found delimiter');           if (!closer) {             num = parseInt(this.split_text_list[index + 1], 10);             console.log(num);             if (isNaN(num)) {               this.add_node(index + 1, false, 'text');             }             if (num === this.list.current_level) {               this.add_node(index + 2);             }             if (num < this.list.current_level) {               this.list.goto_level(num);               this.add_node(index + 2);             }             if (num === this.list.current_level + 1) {               this.add_node(index + 2, false);             }             closer = true;           } else {             closer = false;           }         }       }       this.list.goto_level(1);       return builder = new Builder(this.list);     };      Barn.prototype.add_node = function(index, stepback, type) {       var i, len, ref, res, word;       if (stepback == null) {         stepback = true;       }       if (type == null) {         type = 'heading';       }       if (stepback) {         this.list.back();       }       res = __;       ref = this.split_text_list.slice(index);       for (i = 0, len = ref.length; i < len; i++) {         word = ref[i];         if (word !== delimiter) {           res += word + _ _;           console.log(word);         } else {           break;         }       }       return this.list.add(new Node(res, type));     };      return Barn;    })();    Node = (function() {     function Node(val, type1) {       this.val = val;       this.type = type1;       this.children = [];       this.parent = false;       this.level = 0;     }      Node.prototype.to_str = function() {       var child, i, len, ref, ret;       ret = this.val + _(_ + this.level + _):[_;       ref = this.children;       for (i = 0, len = ref.length; i < len; i++) {         child = ref[i];         ret += (child.to_str()) + _ _;       }       ret += ']';       return ret;     };      return Node;    })();    NodeList = (function() {     function NodeList() {       this.active_node = new Node('first');       this.current_level = 0;     }      NodeList.prototype.add = function(node) {       var child, i, len, ref;       ref = this.active_node.children;       for (i = 0, len = ref.length; i < len; i++) {         child = ref[i];         if (child.val === node.val) {           this.active_node = child;           this.current_level += 1;           return false;         }       }       this.active_node.children.push(node);       node.parent = this.active_node;       this.active_node = node;       console.log(_new active node: _ + this.active_node.val);       this.current_level += 1;       return this.active_node.level = this.current_level;     };      NodeList.prototype.back = function() {       console.log(this.active_node.val);       this.active_node = this.active_node.parent;       return this.current_level -= 1;     };      NodeList.prototype.goto_level = function(level, node) {       if (node == null) {         node = false;       }       console.log(_going to level _ + level);       if (level === this.current_level) {         return true;       }       if (level < this.current_level) {         console.log(this.current_level);         while (this.current_level !== level) {           this.back();         }       }       if (level > this.current_level) {         return console.log(_cant move forwards through the nodelist!!_);       }     };      NodeList.prototype.to_str = function() {       var level, ret;       level = this.current_level;       console.log(_to_str called on level _ + level);       while (this.current_level !== 1) {         this.back();       }       ret = this.active_node.to_str();       return ret;     };      NodeList.prototype.get_active = function() {       return this.active_node;     };      return NodeList;    })();    barn = new Barn();    barn.parse();    console.log(barn.list.to_str());  }).call(this);   delimiter = '*' # * generated by docraiser * class Builder  constructor: (@frame) ->   @body = document.getElementById('main')   console.log(@frame.to_str())   @build(@frame.get_active())   build: (node) ->   console.log(_#{node.type} #{node.val}_)   element = no   if node.type is 'heading'    element = document.createElement(_h#{node.level}_)   if node.type is 'text'    element = document.createElement('a')   element.innerHTML = node.val   @body.appendChild(element)    for a in node.children    @build(a)     class Barn  constructor: ->   # @level = 1   @split_text_list = window.output.split(' ')   @frame = {}   @list = new NodeList()   # console.log(@split_text_list)   parse: ->   closer = no   for index in [0...@split_text_list.length]    # console.log(@split_text_list[index])    if @split_text_list[index] is delimiter     console.log('found delimiter')     if not closer      num = parseInt(@split_text_list[index + 1],10)      console.log(num)      if isNaN(num)       @add_node(index + 1,no,'text')      if num == @list.current_level       @add_node(index + 2)       # level += 1      if num < @list.current_level       @list.goto_level(num)       @add_node(index + 2)      if num is @list.current_level + 1       @add_node(index + 2,no)      closer = yes     else      closer = no    @list.goto_level(1)   # console.log(@list.to_str())   builder = new Builder(@list)   add_node: (index,stepback=yes,type='heading') ->   if stepback    @list.back()   res = __   for word in @split_text_list[index..]    if word isnt delimiter     res += _#{word} _      console.log(word)     else break   @list.add(new Node(res,type))  class Node  constructor: (@val,@type) ->   # a node could have many children but only one parent   @children = []   @parent = no   @level = 0   to_str: () ->   ret = _#{@val}(#{@level}):[_   ret += _#{child.to_str()} _ for child in @children   ret += ']'   return ret  class NodeList  constructor: ->   @active_node = new Node('first')   @current_level = 0   add: (node) ->   # before adding, check if the node is already added   for child in @active_node.children    if child.val is node.val     @active_node = child     @current_level += 1     return no   @active_node.children.push(node)   node.parent = @active_node   @active_node = node   console.log(_new active node: #{@active_node.val}_)   @current_level += 1   @active_node.level = @current_level   back: ->   console.log(@active_node.val)   @active_node = @active_node.parent   @current_level -= 1   goto_level: (level,node=no) ->   console.log(_going to level #{level}_)   if level == @current_level    return yes   if level < @current_level    console.log(@current_level)    @back() while @current_level isnt level   if level > @current_level    console.log(_cant move forwards through the nodelist!!_)   to_str: ->   level = @current_level   console.log(_to_str called on level #{level}_)   @back() while @current_level isnt 1   ret = @active_node.to_str()   # @goto_level(level)   return ret   get_active: ->   @active_node  barn = new Barn() barn.parse() console.log(barn.list.to_str()) "